var baseCtrl = require('./controller/base')

var PRE_HOOk_CONSTANT  = "/_pre"
var POST_HOOK_CONSTANT = "/_post"
/**
 * Adds each route in routes.js as well binds with it base controller's context
 * @param  {Object} app     Express App
 * @param  {String} phase   Phase can be either init, pre, post
 * @param  {Object} routes  All routes defined in a single plugin
 * @param  {Object} route   A single route. Used for recurrtion 
 * @param  {Array}  befores All before hooks associated with a single route
 * @return void
 */
function mapThroughRoutes(app, phase, routes, route, befores, afters) {
  route   = route || ''
  befores = befores || []
  afters  = afters || []

  // Functions that need to be executed before any sub route is executed
  if (typeof routes['before'] === 'function') {
    befores = befores.concat(routes['before'].bind(baseCtrl))
  }

  // Functions that need to be executed after any sub route is executed.bind(baseCtrl))
  if (typeof routes['after'] === 'function') {
    afters = afters.concat(routes['after'].bind(baseCtrl))
  }

  for (var key in routes) {
    if(isRoute(key)){
      mapThroughRoutes(app, phase, routes[key], route + key, befores, afters)
    } else{
      var args
      // Checks if it is a function call
      if(isFunctionCall(route)){
        args = [attachAPIPrefix(route)].concat(routes[key].bind(baseCtrl))
        bindRouteHandler(app, key, args)        
      } else if(phase && utils.isFunction(routes[key][phase])){
        // System is to be started in a given phase ()
        args = hookPreFix(phase, route).concat(befores).concat(routes[key][phase].bind(baseCtrl)).concat(afters)
        bindRouteHandler(app, key, args)
      } else if(utils.isFunction(routes[key]) && phase === "_pre"){
        args = [route].concat(befores).concat(routes[key].bind(baseCtrl)).concat(afters)
        bindRouteHandler(app, key, args)
      }
    }
  }
}

/**
 * Attaches /api/ prefix to a exisiting call
 * @example
 *  input: /classes/class_uid
 *  output: /api/classes/class_uid
 */
function attachAPIPrefix(path){
  return "/api" + path
}

/**
 * Attaches phase prefix to existing call
 *  input: /v1/classes/class_uid
 *  output: /api/_pre/v1/classes/class_uid
 */
function hookPreFix(phase, route){
  var splittedString = phase.split("_")
  if(utils.includes(splittedString, "pre"))
    return [attachAPIPrefix(PRE_HOOk_CONSTANT)+ route]
  if(utils.includes(splittedString, "post"))
    return [attachAPIPrefix(POST_HOOK_CONSTANT) + route]
}

function bindRouteHandler(app, key, args){
  if(utils.includes(["GET", "PUT", "POST", "DELETE"], key.toUpperCase())){
    var callbacks        = args.splice(1, args.length)
    var wrappedCallbacks = wrapCallbacksInPromise(callbacks)
    args.push(wrappedCallbacks)
    key = key.toLowerCase()
    app[key].apply(app, args)

    return
  }
}

function wrapCallbacksInPromise(callbacks){
  return callbacks.map(function(callback){
    return function(req, res, next){
      var middlewarePromise = callback(req, res)
      if(middlewarePromise && middlewarePromise.then){
        middlewarePromise
        .then(function(){
          next()
        }, function(err){
          if(!err.builtResponse)
            next(err)
        })
      }
    }
  })
}

function isFunctionCall(path){
  var regex = new RegExp("\/v[0-9]\/functions\/.*")
  return (typeof path === "string") && !!path.match(regex)
}

/**
 * Method check if the path is of type "/something"
 */
function isRoute(path){
  var regex = new RegExp("\/.*")
  return (typeof path === "string") && !!path.match(regex)
}

module.exports = function(appInstance, coreRoutes, pluginRoutes) {
  // Attach pre save hooks
  mapThroughRoutes.call(null, appInstance, '_pre', coreRoutes)
  mapThroughRoutes.call(null, appInstance, '_pre', pluginRoutes)
  mapThroughRoutes.call(null, appInstance, '_pre_send', coreRoutes)

  // Attach post save hooks
  mapThroughRoutes.call(null, appInstance, '_post', coreRoutes)
  mapThroughRoutes.call(null, appInstance, '_post', pluginRoutes)
  mapThroughRoutes.call(null, appInstance, '_post_send', coreRoutes)
  
  // Error handler
  registerErrorCallback(appInstance)
}

function responseHandler(appInstance){
  appInstance.use(function(req, res, next){
    res.status(200)
    baseCtrl.resSuccess(req, res, req.bobjekt.toJSON ? req.bobjekt.delta : req.bobjekt)
  })
}

/**
 * This method attaches a ExpressJS' error handler which emits a error event.
 */
function registerErrorCallback(appInstance){
  appInstance.use(function(err, req, res, next){
    res.status(422)
    if(err.stack){
      // Need to send this error via socket
      req.logger.error(err.stack.toString())
      res.send()
    } else {
      baseCtrl.resError(req, res, err)
    }
  })
}



